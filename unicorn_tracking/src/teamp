// ------------------------------------------ Association -----------------------------------------------------------------------
/* Associates objects with trackers*/
void tracking_lidar::association()
{
  int i,j,m = 0;
  double dt,time = scan_data_.header.stamp.sec + scan_data_.header.stamp.nsec*pow(10, -9);
  float s1,s2,s3,s4,s5,s6,similarity,sim_adj,x_dot,y_dot, sum[3];

  vector<vector<double>> object_match_ratio(MAX_OBJECTS,vector<double>(MAXTRACKS));

  
  /* Sets start values */
  memset(object_match,0,sizeof(object_match[0])*MAX_OBJECTS);
  //memset(object_match_ratio,0,sizeof(object_match_ratio[0][0])*MAX_OBJECTS*MAXTRACKS);

  /**/
  for(i=0; i<MAX_OBJECTS; i++)
    for(j=0; j<MAXTRACKS; j++)
        object_match_ratio[i][j] = 100;

  /* Check object against current trackers and gets similarity index*/
  for(i=0; i<MAXTRACKS; i++)
  {
    if(trackers[i].age > 0){
      trackers[i].age++;
      trackers[i].last_seen++;

      dt = time - trackers[i].time;  
      for(j=0; j<MAX_OBJECTS; j++)
      {
        if(polygon_size[j] >= 1){
          calculateVel(j, i,sum);
          s1 = sim_adj_angle*abs((trackers[i].average_angle) - (object_attributes_list[j].average_angle));
          s2 = sim_adj_dist*abs((trackers[i].longest_size) - (object_attributes_list[j].longest_size));
          s3 = sim_adj_side*abs((trackers[i].sides_amount) - (object_attributes_list[j].sides_amount));  
          s4 = sim_adj_xpos*abs((trackers[i].tracker.x_hat(0)) - (object_attributes_list[j].estimated_x));
          s5 = sim_adj_ypos*abs((trackers[i].tracker.x_hat(2)) - (object_attributes_list[j].estimated_y));

          if(s1 > s2)
          {
            similarity = s2;
          }else{
            similarity = s1;
          }
          if(isnan(s4 + s5))
          {
            s4 = 5;
            s5 = 5;
          }
          if(isnan(s6))
          {
            s6 = sim_adj_posdiff;
          }
          similarity += s3 + s4 + s5 + s6;
          similarity /= (sim_adj_dist + sim_adj_angle + sim_adj_side + sim_adj_xpos + sim_adj_ypos + sim_adj_posdiff);
          
          if(trackers[i].age > CONFIRMED_TRACK)
            similarity *= 0.9;
          if(!isnan(similarity))
            object_match_ratio[i][j] = double(similarity); 
        }
      }  
    }
  }

  /* Hungarian algorithm to find the best match for the trackers */
  HungarianAlgorithm HungAlgo;
  vector<int> assignment;
  double cost = HungAlgo.Solve(object_match_ratio, assignment);

  
  /* Associates trackers according to cost*/
  for (m = 0; m < MAXTRACKS; m++)
  {
    if(object_match_ratio[m][assignment[m]] < max_similarty_deviation)
    {
      dt = time - trackers[m].time;
      object_match[assignment[m]] = 1; 
      trackers[m].last_seen = 0; 
      j = assignment[m];

      trackers[m].average_angle = object_attributes_list[j].average_angle;
      trackers[m].longest_size = object_attributes_list[j].longest_size;
      trackers[m].sides_amount = object_attributes_list[j].sides_amount;
      /*
      x_dot = (trackers[m].tracker.x_hat(0)-object_attributes_list[j].estimated_x)/float(dt);
      y_dot = (trackers[m].tracker.x_hat(2)-object_attributes_list[j].estimated_y)/float(dt);
      */
      calculateVel(j, m,sum);
      x_dot = sum[1];
      y_dot = sum[2];
      if(isnan(x_dot))
        x_dot = 0;
      if(isnan(y_dot))
        y_dot = 0;

      trackers[m].tracker.y << object_attributes_list[j].estimated_x, x_dot, object_attributes_list[j].estimated_y,y_dot; 
      trackers[m].points.points.clear();
      trackers[m].points = shapes[j];
      trackers[m].time = time;
    }else{
      trackers[m].last_seen++;
    }
      
  }
		 
  /*  Remove old trackers */
  for(i=0; i<MAXTRACKS; i++){
    if(trackers[i].age > 0){
      if((trackers[i].last_seen > TRACKER_LIFE) || (trackers[i].age < CONFIRMED_TRACK && trackers[i].last_seen > 1))
      {
        trackers[i].tracker.initialized = false;
        trackers[i].age = 0;
      }
    }
  }

   
  /* Adds new trackers */
  m = 0;
  for(j=0; j<MAX_OBJECTS; j++)
  {
    if(trackers[j].age > 0)
      m++;
    if(polygon_size[j] >= 1 && object_match[j] == 0)
    {
      for(i=0; i<MAXTRACKS; i++)
      {    
        if(trackers[i].age == 0)
        {
          trackers[i].age = 1;
          trackers[i].average_angle = object_attributes_list[j].average_angle;
          trackers[i].longest_size = object_attributes_list[j].longest_size;
          trackers[i].sides_amount = object_attributes_list[j].sides_amount;
          trackers[i].time = time;
          trackers[i].last_seen = 0;
          trackers[i].tracker.init();
          trackers[i].tracker.x_hat << object_attributes_list[j].estimated_x, 0,object_attributes_list[j].estimated_y, 0;
          trackers[i].tracker.y << object_attributes_list[j].estimated_x, 0, object_attributes_list[j].estimated_y, 0;
          trackers[i].color[0] = 1;
          trackers[i].color[1] = float(rand() % 80 + 20)/100;
          trackers[i].color[2] = float(rand() % 80 + 20)/100;
          trackers[i].color[3] = float(rand() % 80 + 20)/100;
          trackers[i].points.points.clear();
          trackers[i].points = shapes[j];
          break;
        }
      }
    }
  }
  ROS_INFO("Number of trackers %d",m);
}

/* Estimates the movment between an object a a tracker*/
void tracking_lidar::calculateVel(int objectnr, int trackernr,float *sum)
{
  int i,j;

  float x_t,y_t,x_o,y_o,distance;

  geometry_msgs::Polygon points;
  geometry_msgs::Point32 point1;
  
  point1.z = 10;
  point1.x = 0;
  point1.y = 0;
  sum[0] = 0;
  sum[1] = 0;
  sum[2] = 0;
  /* Checks minimum movent between each point recorded in the tracker and the repective object*/
  for(j=0;j < (int)(trackers[trackernr].points.points.size()); j++)
  {
    x_t = trackers[trackernr].points.points[j].x;
    y_t = trackers[trackernr].points.points[j].y;
    point1.z = 10;
    point1.x = 0;
    point1.y = 0;
    for(i=0;i < (int)(object_attributes_list[objectnr].points.points.size());i++)
    {
      x_o = object_attributes_list[objectnr].points.points[i].x;
      y_o = object_attributes_list[objectnr].points.points[i].y;
      distance = sqrt(pow(x_o-x_t,2)+pow(y_o-y_t,2));
      // new positon
      if(distance < point1.z){
         point1.z = distance;
         point1.x = x_o-x_t;
         point1.y = y_o-y_t;
      }
    }
    if(point1.z < 10)
      points.points.push_back(point1);

  }
  j=1;
  for(i=0;i<(int)(points.points.size());i++)
    if(points.points[i].z < 10)
    {
      j++;
      sum[0] += points.points[i].z;
      sum[1] += points.points[i].x;
      sum[2] += points.points[i].y;
    }
  sum[0] /= j;
  sum[1] /= j;
  sum[2] /= j;
}


// ------------------------------------------ Association -----------------------------------------------------------------------
// ------------------------------------------ Shape Extraction -----------------------------------------------------------------------

/* Clusters data into groups */
void tracking_lidar::adaptive_breaK_point()
{
  int i,j = 0;
  float current_angle,r,p,dmax, x_t, y_t;
  double roll_map, pitch_map, yaw_map;
  geometry_msgs::Point point;
  polygon_points clustered_point;
  polygon_point_list.clear();
  int max_itterations = round((scan_data_.angle_max - scan_data_.angle_min)/scan_data_.angle_increment);

  odom2map = tf_buffer.lookupTransform(mapframeid, odomframeid, ros::Time(0),ros::Duration(5));
  
  for(i = 0; i < max_itterations+1; i++)
  {
    polygon_point_list.push_back(clustered_point);
    current_angle = float(i)*scan_data_.angle_increment+scan_data_.angle_min;

    // Calculate xy position
    //point.x = (scan_data_.ranges[i])*(cos(current_angle)*cos(yaw) + sin(current_angle)*sin(yaw));
    //point.y = (scan_data_.ranges[i])*(sin(current_angle)*cos(yaw) - cos(current_angle)*sin(yaw));
    point.z = 0;
    point.x = (scan_data_.ranges[i])*cos(current_angle);
    point.y  = (scan_data_.ranges[i])*sin(current_angle);

    tf2::doTransform(point,point,Lidar2base);

    x_t = point.x;
    y_t = point.y;
    point.x = x_t*cos(yaw) + y_t*sin(yaw);
    point.y = y_t*cos(yaw) - x_t*sin(yaw);

    point.x += x;
    point.y += y;
    point.z = 0;


    // transform to map
    tf2::doTransform(point,point,odom2map);

    polygon_point_list[i].range = scan_data_.ranges[i];
    polygon_point_list[i].angle = current_angle;

    polygon_point_list[i].point.x = point.x;
    polygon_point_list[i].point.y = point.y;
    if(i == 0)
    {
      polygon_point_list[i].cluster = 0;
    }else
    {
      r = sqrt(pow(polygon_point_list[i-1].point.x,2) + pow(polygon_point_list[i-1].point.y,2));
      p = sqrt(pow(polygon_point_list[i-1].point.x - polygon_point_list[i].point.x,2) + pow(polygon_point_list[i-1].point.y - polygon_point_list[i].point.y,2));
      dmax = r*sin(scan_data_.angle_increment)/sin(lambda + scan_data_.angle_increment) + 3*scan_data_.angle_increment;
      if(dmax < p)
        j++;
      

      polygon_point_list[i].cluster = j;
    }
    /* Filters scans that over a set threshold*/
    if(scan_data_.ranges[i] > max_dist_laser){
      polygon_point_list[i].cluster = -1;
    }
  }
}

/* Filters static map from scan, requires reliable odometry and static map*/
void tracking_lidar::static_map_filter()
{
  if(!static_filter)
    return;

  int i,m,n;
  int x_map,y_map;
  for(i=0; i < SCAN_SIZE;i++){
    x_map = round((int)((float)polygon_point_list[i].point.x/(map_data_.info.resolution))) + ((int)(map_data_.info.width)/2);
    y_map = round((int)((float)polygon_point_list[i].point.y/(map_data_.info.resolution))) + ((int)(map_data_.info.height)/2);
    if(polygon_point_list[i].cluster != -1)
    {
      for(m=-static_remove_dist; m <= static_remove_dist;m++)
        for(n=-static_remove_dist; n <= static_remove_dist;n++){
          if(((x_map+m) < (int)map_data_.info.height && (y_map+n) < (int)map_data_.info.width)){
            if((0 < (x_map+m)) && (0 < (y_map+n)))
            {
              if(map_data_.data[(x_map+m) + (y_map+n)*map_data_.info.width] > 0){
                polygon_point_list[i].cluster = -1;
                m = static_remove_dist+1;
                n = static_remove_dist+1;
              }
            }
          }
        }
    }
  }
}



/* Extracts polygon shapes from lidar clusters*/
void tracking_lidar::polygon_extraction(){
  int i,j, current_cluster = polygon_point_list[0].cluster, m = 0,n,l;
  int start_point = 0, end_point;
  geometry_msgs::Point32 point;

  // Clear shape array
  for(i=0; i < MAX_OBJECTS; i++)
  {
    if(polygon_size[i] >= 1)
    {
      shapes[i].points.clear();
      polygon_size[i] = 0;
    }
  }


  object_attributes_list[m].points.points.clear();
  for(i=1; i < SCAN_SIZE; i++){
    polygon_point_list[i].polygon_num = 0;
    point.x = polygon_point_list[i].point.x;
    point.y = polygon_point_list[i].point.y;
    point.z = 0;
    object_attributes_list[m].points.points.push_back(point);
    if(polygon_point_list[i].cluster != current_cluster){ 
      end_point = i-1;
      if(current_cluster != -1 && end_point-start_point > min_size_cluster){
          l = end_point-start_point+1;
          if(l >= 3){
            polygon_point_list[start_point].polygon_num = 1;
            polygon_size[m]++;
            polygon_point_list[end_point].polygon_num = 1;
            polygon_size[m]++;
            extract_corners(start_point,end_point,end_point-start_point+1,m);
            
            for(j = start_point;j <= end_point; j++)
            {
              if(polygon_point_list[j].polygon_num)
              {
                point.x = polygon_point_list[j].point.x;
                point.y = polygon_point_list[j].point.y;
                point.z = 0;
                shapes[m].points.push_back(point);
              }
            }
            m++;
            object_attributes_list[m].points.points.clear();
          }
      }
      current_cluster = polygon_point_list[i].cluster;
      start_point = i;
    }
  }
}

/*  Finds all corners between two points that satisfy a threshold*/
void tracking_lidar::extract_corners(int startpoint,int endpoint, int length,int shape_nr)
{
  if(length < polygon_min_points)
    return;
  
  int max_itteration = ceil(log2(float(length)));
  float distance_start =  sqrt(pow(polygon_point_list[startpoint].point.x - polygon_point_list[startpoint + length - 1].point.x,2) + pow(polygon_point_list[startpoint].point.y - polygon_point_list[startpoint + length - 1].point.y,2));
  int bestpoint = startpoint;
  float bestdist = distance_start;
  int *best_point = &bestpoint;
  float *best_dist = &bestdist;
  int j = floor(float(length)/(2));
  search_longest(startpoint, startpoint+length-1,startpoint+j-1, length, distance_start, 1, max_itteration, best_point, best_dist);
  if((*best_dist) > distance_start*polygon_tolerance)
  { 
    if(polygon_point_list[*best_point].polygon_num == 0)
    {   
      polygon_point_list[*best_point].polygon_num = 1;
      polygon_size[shape_nr]++;
      extract_corners(startpoint,*best_point,*best_point-startpoint+1,shape_nr);
      extract_corners(*best_point,endpoint,endpoint-*best_point+1,shape_nr);
    }
  }
}

/* Searches for a point that would maximize the distance between the start and end point*/ 
void tracking_lidar::search_longest(int startpoint,int end_point, int current_point, int length, float distance_S, int itteration, int max_itteration, int *best_point, float *best_dist)
{
  if(length < 1 || (startpoint+length)>799)
    return;
  if(current_point < startpoint || current_point > end_point)
    return; 

  float distance_1, distance_2, distance_total;
  int j;
  
  itteration++;
  distance_1 =  sqrt(pow(polygon_point_list[startpoint].point.x - polygon_point_list[current_point].point.x,2) + pow(polygon_point_list[startpoint].point.y - polygon_point_list[current_point].point.y,2));
  distance_2 =  sqrt(pow(polygon_point_list[current_point].point.x - polygon_point_list[end_point].point.x,2) + pow(polygon_point_list[current_point].point.y - polygon_point_list[end_point].point.y,2));
  distance_total = distance_1 + distance_2;
  if(distance_total > *best_dist){
    *best_point = current_point;
    *best_dist = distance_total;
  }

  if(itteration < max_itteration)
    if(distance_total > distance_S*0.8)
    {
      if(distance_total < distance_S)
        distance_total = distance_S;
      j = floor(float(length)/pow(2,itteration));
      if(j > 0)
      {
        search_longest(startpoint,end_point, current_point+j, length, distance_total, itteration, max_itteration, best_point, best_dist);
        search_longest(startpoint,end_point, current_point-1, length, distance_total, itteration, max_itteration, best_point, best_dist);
      }
    }
}

/* Collects information polygon attributes for a simularity comparison*/
void tracking_lidar::polygon_attribute_extraction()
{
  int i,j, m = 0;
  geometry_msgs::Point32 point1,point2,point3;
  float length1,length2,length3, angle,lowest_angle;
  for(i=0; i < MAX_OBJECTS; i++){
    object_attributes_list[i].longest_size = 0;
    object_attributes_list[i].sides_amount = 0;
    object_attributes_list[i].estimated_x = 0;
    object_attributes_list[i].estimated_y = 0;
    object_attributes_list[i].average_angle = 0;
    if(polygon_size[i] >= 1){
      /* Get angle average, length average*/
      for(j=0;j < polygon_size[i]-1;j++)
      {
        point1 = shapes[i].points[j];
        point2 = shapes[i].points[j+1];
        length1 = sqrt(pow(point1.x - point2.x,2) + pow(point1.y - point2.y,2));
        if(length1 >object_attributes_list[i].longest_size)
         object_attributes_list[i].longest_size = length1;

        object_attributes_list[i].sides_amount++;
        object_attributes_list[i].estimated_x += point1.x;
        object_attributes_list[i].estimated_y += point1.y;
        if(polygon_size[i]-j > 2)
        {
          point3 = shapes[i].points[j+2];
          length2 = sqrt(pow(point3.x - point2.x,2) + pow(point3.y - point2.y,2));
          length3 = sqrt(pow(point3.x - point1.x,2) + pow(point3.y - point1.y,2));
          angle = acos((pow(length1,2) + pow(length2,2) - pow(length3,2))/(2*length1*length2));
          object_attributes_list[i].average_angle += angle;
        }
      }
      object_attributes_list[i].estimated_x += point2.x;
      object_attributes_list[i].estimated_y += point2.y;

      object_attributes_list[i].estimated_x /= polygon_size[i];
      object_attributes_list[i].estimated_y /= polygon_size[i];
      if(polygon_size[i]-2 > 0)
        object_attributes_list[i].average_angle /= polygon_size[i]-2;

    }
  }
}

// ------------------------------------------ Shape Extraction -----------------------------------------------------------------------